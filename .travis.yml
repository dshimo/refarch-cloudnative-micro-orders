sudo: required
language: java
jdk:
  - openjdk8
env:
  global:
    - zipkinHost=localhost
    - zipkinPort=9411
    - IMAGE_NAME=orders
    - RELEASE_NAME=orders
    - TAG=travis
    - MYSQL_DATABASE=ordersdb

stages:
  - local build and test
  - docker build, deploy, and test
  - kubernetes build, deploy, and test
jobs:
  include:
    - stage: local build and test
      services:
      - mysql
      env:
        - jdbcURL=jdbc:mysql://localhost:9039/ordersdb?useSSL=false
        - dbuser=root
        - dbpassword=password
        - auth_health=https://localhost:9443/health
        - inventory_url=http://localhost:9081/inventory/rest/inventory/stock
        - inventory_health=http://localhost:9081/health
        - rabbit=localhost
        - jwksUri=https://localhost:9443/oidc/endpoint/OP/jwk
        - jwksIssuer=https://localhost:9443/oidc/endpoint/OP
        - administratorRealm=https://localhost:9443/oidc/endpoint/OP
        - MYSQL_HOST=127.0.0.1
        - MYSQL_PORT=3306
        - MYSQL_USER=root
        - MYSQL_PASSWORD=""
      before_script:
      # Generate the Keystore
      - bash scripts/keygen.sh
      - sudo cp -r keystorevol /etc/
      # Run Auth, put keystore in, and start it
      - docker pull ibmcase/auth-mp:v3.0.0
      - docker create --name auth -p 9443:9443 -p 9080:9080 ibmcase/auth-mp:v3.0.0
      - docker cp keystorevol auth:/etc/
      - docker start auth
      # Pull and run inventorydb
      - docker pull ibmcase/bc-inventorydb:v2.0.0
      - docker run -p 9041:3306 -d --name inventorydb -e MYSQL_ROOT_PASSWORD=password ibmcase/bc-inventorydb:v2.0.0
      - export GATEWAY=$(docker network inspect bridge | grep "Gateway" | awk '/"/{print $2}' | sed -e 's/^"//' -e 's/"$//')
      # Run Inventory, put keystore in, and start it w/ vars
      - docker pull ibmcase/inventory-mp:v2.0.0
      - docker create --name inventory -p 9444:9443 -p 9081:9080 -e jdbcURL=jdbc:mysql://${GATEWAY}:9041/inventorydb?useSSL=false -e dbuser=root -e dbpassword=password -e rabbit=${GATEWAY} ibmcase/inventory-mp:v2.0.0
      - docker cp keystorevol inventory:/etc/
      - docker start inventory
      # Build and run ordersdb
      - cd mysql
      - docker build -t ordersdb .
      - docker run -p 9039:3306 -d --name ordersdb -e MYSQL_ROOT_PASSWORD=password ordersdb
      - cd -
      # Start RabbitMQ
      - docker pull rabbitmq
      - docker run -p 5672:5672 -d rabbitmq
      script:
      # Maven Build
      - mvn clean install
      # Start Application
      - mvn liberty:start-server -DtestServerHttpPort=9083 -DtestServerHttpsPort=9446
      # Wait for the Orders container to start accepting connections
      - sleep 25
      # Run Orders API Test
      - bash scripts/api_tests.sh

    # - stage: docker build, deploy, and test
    #   services:
    #   - docker
    #   install:
    #     - true
    #   env:
    #     - MYSQL_ROOT_PASSWORD=admin123
    #     - MYSQL_PORT=3307
    #     - MYSQL_USER=dbuser
    #     - MYSQL_PASSWORD=password
    #   before_script:
    #   # Start Docker Container
    #   - docker run --name ordersmysql -p ${MYSQL_PORT}:3306 -d -e MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} -e MYSQL_USER=${MYSQL_USER} -e MYSQL_PASSWORD=${MYSQL_PASSWORD} -e MYSQL_DATABASE=${MYSQL_DATABASE} mysql:5.7.14
    #   # Wait MySQL
    #   - until mysql -h 127.0.0.1 -P ${MYSQL_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} -e status; do echo "waiting for mysql"; sleep 1; done; echo "MySQL Started"
    #   # Get IP Address for MySQL
    #   - MYSQL_HOST=$(docker inspect ordersmysql | jq -r '.[0].NetworkSettings.IPAddress')
    #   script:
    #   # Build Docker image
    #   - docker build -t "${IMAGE_NAME}:${TAG}" .
    #   # Start Orders Container and Connect to local MySQL Service
    #   - docker run --name orders -p 8084:8084 -d -e MYSQL_HOST=${MYSQL_HOST} -e MYSQL_PORT=3306 -e MYSQL_USER=${MYSQL_USER} -e MYSQL_PASSWORD=${MYSQL_PASSWORD} -e MYSQL_DATABASE=${MYSQL_DATABASE} -e HS256_KEY="${HS256_KEY}" "${IMAGE_NAME}:${TAG}"
    #   # Wait for the Orders container to start accepting connections
    #   - sleep 25
    #   # Check that the Orders container is running
    #   - docker ps
    #   # Check logs to see if it started properly
    #   - docker logs orders
    #   # Run Orders API Test
    #   - bash scripts/api_tests.sh 127.0.0.1 8084 ${HS256_KEY}
    # - stage: kubernetes build, deploy, and test
    #   services:
    #   - docker
    #   install:
    #     - true
    #   env:
    #     - CHANGE_MINIKUBE_NONE_USER=true
    #     - MYSQL_ROOT_PASSWORD=admin123
    #     - MYSQL_PORT=3307
    #     - MYSQL_USER=dbuser
    #     - MYSQL_PASSWORD=password
    #   before_script:
    #   # Install nsenter, which is needed for minikube to work
    #   - bash scripts/install_minikube_and_helm.sh
    #   # Install MariaDB Chart
    #   - helm upgrade --install orders-mariadb --version 5.2.2 --set service.port=${MYSQL_PORT},nameOverride=orders-mariadb,rootUser.password=${MYSQL_ROOT_PASSWORD},db.user=${MYSQL_USER},db.password=${MYSQL_PASSWORD},db.name=${MYSQL_DATABASE},replication.enabled=false,master.persistence.enabled=false,slave.replicas=1,slave.persistence.enabled=false stable/mariadb
    #   script:
    #   # Build Docker image
    #   - docker build -t "${IMAGE_NAME}:${TAG}" .
    #   # Download Orders chart dependencies (MySQL)
    #   - cd chart/orders; helm dependency update; cd ../..
    #   # helm lint
    #   - helm lint chart/orders
    #   # helm package
    #   - helm package chart/orders
    #   # helm install Orders from packaged chart. Use pullPolicy=Never so it uses local docker image
    #   - CHART_VERSION="$(cat chart/orders/Chart.yaml | grep version | awk '{print $2}')"
    #   - helm upgrade --install orders --set service.type=NodePort,mariadb.user=${MYSQL_USER},mariadb.password=${MYSQL_PASSWORD},mariadb.database=${MYSQL_DATABASE},image.repository="${IMAGE_NAME}",image.tag="${TAG}",image.pullPolicy=Never orders-${CHART_VERSION}.tgz
    #   # Wait for Orders to be ready
    #   - kubectl get deployments ${RELEASE_NAME}-orders -o yaml
    #   - READY=$(kubectl get deployments ${RELEASE_NAME}-orders -o yaml | grep "readyReplicas" | awk '{print $2}')
    #   - echo $READY
    #   - until [ -n "$READY" ] && [ ${READY} -ge 1 ]; do READY=$(kubectl get deployments ${RELEASE_NAME}-orders -o yaml | grep "readyReplicas" | awk '{print $2}'); kubectl get deployments -o wide; echo "Waiting for orders to be ready"; sleep 10; done
    #   # Wait for Orders deployment to start accepting connections
    #   - sleep 35
    #   # Run Orders API Test
    #   - MINIKUBE_IP=$(minikube ip)
    #   - NODE_PORT=$(kubectl get service ${RELEASE_NAME}-orders -o=jsonpath='{.spec.ports[0].nodePort}')
    #   - bash scripts/api_tests.sh ${MINIKUBE_IP} ${NODE_PORT} ${HS256_KEY}